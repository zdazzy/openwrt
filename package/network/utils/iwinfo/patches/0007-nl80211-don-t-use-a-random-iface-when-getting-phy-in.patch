From 696cace0b151c36ba18017fc053e8f0fbb4c4c62 Mon Sep 17 00:00:00 2001
From: Andre Heider <a.heider@gmail.com>
Date: Tue, 15 Nov 2022 14:12:49 +0100
Subject: [PATCH 07/12] nl80211: don't use a random iface when getting phy
 infos

One phy can have more than one wifi-iface. When getting just the
phy infos, don't get iface specific values of some random iface
from that phy, that's just not right and confusing.

Note:
This removes bssid, mode, quality_max and noise
from the phy result table of e.g:
$ ubus call iwinfo info '{"device":"phy0"}'

But there're of course still present for ifaces, e.g.:
$ ubus call iwinfo info '{"device":"wlan0"}'`

And more importantly this is unchanged:
$ ubus call luci-rpc getWirelessDevices

(Which has iface _and_ phy iwinfo tables, where the latter already
doesn't include the values removed here).

Signed-off-by: Andre Heider <a.heider@gmail.com>
---
 iwinfo_nl80211.c | 40 ++++++++++++++++++++++++++++------------
 1 file changed, 28 insertions(+), 12 deletions(-)

--- a/iwinfo_nl80211.c
+++ b/iwinfo_nl80211.c
@@ -820,13 +820,12 @@ static int nl80211_get_mode_cb(struct nl
 
 static int nl80211_get_mode(const char *ifname, int *buf)
 {
-	char *res;
-
 	*buf = IWINFO_OPMODE_UNKNOWN;
 
-	res = nl80211_phy2ifname(ifname);
+	if (!nl80211_is_ifname(ifname))
+		return -1;
 
-	nl80211_request(res ? res : ifname, NL80211_CMD_GET_INTERFACE, 0,
+	nl80211_request(ifname, NL80211_CMD_GET_INTERFACE, 0,
 	                nl80211_get_mode_cb, buf);
 
 	return (*buf == IWINFO_OPMODE_UNKNOWN) ? -1 : 0;
@@ -1243,14 +1242,15 @@ static int nl80211_get_ssid_bssid_cb(str
 
 static int nl80211_get_ssid(const char *ifname, char *buf)
 {
-	char *res;
 	struct nl80211_ssid_bssid sb = { .ssid = (unsigned char *)buf };
 
+	if (!nl80211_is_ifname(ifname))
+		return -1;
+
 	/* try to find ssid from scan dump results */
-	res = nl80211_phy2ifname(ifname);
 	sb.ssid[0] = 0;
 
-	nl80211_request(res ? res : ifname, NL80211_CMD_GET_SCAN, NLM_F_DUMP,
+	nl80211_request(ifname, NL80211_CMD_GET_SCAN, NLM_F_DUMP,
 	                nl80211_get_ssid_bssid_cb, &sb);
 
 	/* failed, try to find from hostapd info */
@@ -1260,7 +1260,7 @@ static int nl80211_get_ssid(const char *
 
 	/* failed, try to obtain Mesh ID */
 	if (sb.ssid[0] == 0)
-		iwinfo_ubus_query(res ? res : ifname, "mesh_id",
+		iwinfo_ubus_query(ifname, "mesh_id",
 		                  sb.ssid, IWINFO_ESSID_MAX_SIZE + 1);
 
 	return (sb.ssid[0] == 0) ? -1 : 0;
@@ -1268,18 +1268,19 @@ static int nl80211_get_ssid(const char *
 
 static int nl80211_get_bssid(const char *ifname, char *buf)
 {
-	char *res, bssid[sizeof("FF:FF:FF:FF:FF:FF\0")];
+	char bssid[sizeof("FF:FF:FF:FF:FF:FF\0")];
 	struct nl80211_ssid_bssid sb = { };
 
-	res = nl80211_phy2ifname(ifname);
+	if (!nl80211_is_ifname(ifname))
+		return -1;
 
 	/* try to obtain mac address via NL80211_CMD_GET_INTERFACE */
-	nl80211_request(res ? res : ifname, NL80211_CMD_GET_INTERFACE, 0,
+	nl80211_request(ifname, NL80211_CMD_GET_INTERFACE, 0,
 	                nl80211_get_macaddr_cb, &sb);
 
 	/* failed, try to find bssid from scan dump results */
 	if (sb.bssid[0] == 0)
-		nl80211_request(res ? res : ifname,
+		nl80211_request(ifname,
 		                NL80211_CMD_GET_SCAN, NLM_F_DUMP,
 		                nl80211_get_ssid_bssid_cb, &sb);
 
@@ -1571,6 +1572,9 @@ static int nl80211_get_bitrate(const cha
 {
 	struct nl80211_rssi_rate rr;
 
+	if (!nl80211_is_ifname(ifname))
+		return -1;
+
 	nl80211_fill_signal(ifname, &rr);
 
 	if (rr.rate_samples)
@@ -1586,6 +1590,9 @@ static int nl80211_get_signal(const char
 {
 	struct nl80211_rssi_rate rr;
 
+	if (!nl80211_is_ifname(ifname))
+		return -1;
+
 	nl80211_fill_signal(ifname, &rr);
 
 	if (rr.rssi_samples)
@@ -1629,6 +1636,9 @@ static int nl80211_get_noise(const char
 {
 	int8_t noise = 0;
 
+	if (!nl80211_is_ifname(ifname))
+		return -1;
+
 	if (nl80211_request(ifname, NL80211_CMD_GET_SURVEY, NLM_F_DUMP,
 	                    nl80211_get_noise_cb, &noise))
 		goto out;
@@ -1675,6 +1685,9 @@ static int nl80211_get_quality(const cha
 
 static int nl80211_get_quality_max(const char *ifname, int *buf)
 {
+	if (!nl80211_is_ifname(ifname))
+		return -1;
+
 	/* The cfg80211 wext compat layer assumes a maximum
 	 * quality of 70 */
 	*buf = 70;
@@ -1814,6 +1827,9 @@ static int nl80211_get_encryption(const
 
 	struct iwinfo_crypto_entry *c = (struct iwinfo_crypto_entry *)buf;
 
+	if (!nl80211_is_ifname(ifname))
+		return -1;
+
 	/* WPA supplicant */
 	if (nl80211_wpactl_query(ifname,
 			"pairwise_cipher", wpa_pairwise,  sizeof(wpa_pairwise),
